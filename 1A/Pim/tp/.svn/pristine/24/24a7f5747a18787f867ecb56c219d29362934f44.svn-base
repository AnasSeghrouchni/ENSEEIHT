% Validation de http://hpxc/cregut.svn.enseeiht.fr/2021/1sn/pim/tps/aseghrou/tp10
% Run on 2021-12-06 08:08:38.536652


################################################################################
# Modification des fichiers fournis
################################################################################


================================================================================
## Fichiers qui NE devaient PAS être modifiés
================================================================================

* Fichier alea.adb non modifié... ok
* Fichier alea.ads non modifié... ok
* Fichier exemple_alea.adb non modifié... ok
* Fichier exemple_unbounded_string.adb non modifié... ok
* Fichier sda_exceptions.ads non modifié... ok
* Fichier test_lca.adb non modifié... ok

================================================================================
## Fichiers qui DEVAIENT être modifiés
================================================================================

* Fichier lca_sujet.adb modifié... ok
* Fichier lca.ads modifié... ok
* Fichier lca.adb modifié... ok
* Fichier evaluer_alea_lca.adb modifié... ok
* Fichier th_sujet.adb modifié... ok
* Fichier test_th.adb modifié... ok
* Fichier th.ads modifié... ok
* Fichier th.adb modifié... ok
* Fichier evaluer_alea_th.adb modifié... ok


################################################################################
# Nettoyer
################################################################################

* Running gnatclean... ok


################################################################################
# Exercice 1
################################################################################


================================================================================
## Modifications de lca.ads
================================================================================

* Comparaison de lca.ads et fournis/lca.ads... différents

   | -- AVEC_AFFICHER_DEBUG START DELETE                                                                <
   |         -- Afficher la Sda en révélant sa structure interne.                                       <
   |         --generic                                                                                  <
   |                 --with procedure Afficher_Cle (Cle : in T_Cle);                                    <
   |                 --with procedure Afficher_Donnee (Donnee : in T_Donnee);                           <
   |         --procedure Afficher_Debug (Sda : in T_LCA);                                               <
   |                                                                                                    <
   |                                                                                                    <
   | -- AVEC_AFFICHER_DEBUG STOP DELETE                                                                 <
   |     type T_Cellule;                                                                                <
   |     type T_LCA is access  T_Cellule;                                                               <
   |     type T_Cellule is record                                                                       <
   |         Cle : T_Cle;                                                                               <
   |         Donnes: T_Donnee;                                                                          <
   |         Prochain : T_LCA;                                                                          <
   |     end record;                                                                                    <
   | end LCA;                                                                                           |          -- TODO : à compléter
   |                                                                                                    >  end LCA;


================================================================================
## Exécution de lca_sujet.adb
================================================================================

* Compilation de lca_sujet.adb... ok
* ./lca_sujet... ok
* valgrind ./lca_sujet... ok

================================================================================
## Exécution de test_lca.adb
================================================================================

* Compilation de test_lca.adb... ok

  | test_lca.adb:257:17: warning: variable "Inutile" is assigned but never read
  | test_lca.adb:280:35: warning: formal parameter "Cle" is not referenced

* ./test_lca... ok
* valgrind ./test_lca... ERREUR

  ! ==297587== Memcheck, a memory error detector
  ! ==297587== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==297587== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
  ! ==297587== Command: ./test_lca
  ! ==297587== 
  ! ==297587== 
  ! ==297587== HEAP SUMMARY:
  ! ==297587==     in use at exit: 1,312 bytes in 28 blocks
  ! ==297587==   total heap usage: 169 allocs, 141 frees, 12,672 bytes allocated
  ! ==297587== 
  ! ==297587== 1,312 (48 direct, 1,264 indirect) bytes in 1 blocks are definitely lost in loss record 24 of 24
  ! ==297587==    at 0x4843839: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==297587==    by 0x4AE1FEE: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297587==    by 0x4B0F50C: system__pool_global__allocate (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297587==    by 0x4B1F176: system__storage_pools__subpools__allocate_any_controlled (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297587==    by 0x10DD16: test_lca__lca_string_integer__enregistrer__P321b.7 (lca.adb:44)
  ! ==297587==    by 0x10DB35: test_lca__lca_string_integer__enregistrer.6 (lca.adb:35)
  ! ==297587==    by 0x10F056: test_lca__construire_exemple_sujet.3 (test_lca.adb:77)
  ! ==297587==    by 0x10F434: test_lca__tester_supprimer_inverse.26 (test_lca.adb:115)
  ! ==297587==    by 0x10D33E: _ada_test_lca (test_lca.adb:372)
  ! ==297587==    by 0x10CBEC: main (b~test_lca.adb:288)
  ! ==297587== 
  ! ==297587== LEAK SUMMARY:
  ! ==297587==    definitely lost: 48 bytes in 1 blocks
  ! ==297587==    indirectly lost: 1,264 bytes in 27 blocks
  ! ==297587==      possibly lost: 0 bytes in 0 blocks
  ! ==297587==    still reachable: 0 bytes in 0 blocks
  ! ==297587==         suppressed: 0 bytes in 0 blocks
  ! ==297587== 
  ! ==297587== For lists of detected and suppressed errors, rerun with: -s
  ! ==297587== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)



################################################################################
# Exercice 2
################################################################################


================================================================================
## Différences entre lca.ads et th.ads
================================================================================

* Comparaison de lca.ads et th.ads... différents

   |                                                                                                    |  -- Définition de structures de données associatives sous forme d'une table de hachage
   | -- Définition de structures de données associatives sous forme d'une liste                         |  -- (TH).
   | -- chaînée associative (LCA).                                                                      |  with LCA;
   |         type T_Cle is private;                                                                     |      type T_Cle_t is private;
   |         type T_Donnee is private;                                                                  |      type T_Donnee_t is private;
   |                                                                                                    >      Capacite : Integer;
   |                                                                                                    >      with function Fh(Cle : in T_Cle_t) return integer;
   |                                                                                                    >
   | package LCA is                                                                                     |  package TH is
   |                                                                                                    >
   |                                                                                                    >      package LCA_t is
   |                                                                                                    >                  new LCA (T_Cle =>T_Cle_t , T_Donnee => T_Donnee_t);
   |                                                                                                    >      use LCA_t;
   |         -- Initialiser une Sda.  La Sda est vide.                                                  |          -- Initialiser une TH.  La TH est vide.
   |         procedure Initialiser(Sda: out T_LCA) with                                                 |          procedure Initialiser_t(T: out T_TH) with  
   |                 Post => Est_Vide (Sda);                                                            |                  Post => Est_Vide_t (T);
   |         -- Est-ce qu'une Sda est vide ?                                                            |          -- Est-ce qu'une TH est vide ?
   |         function Est_Vide (Sda : T_LCA) return Boolean;                                            |          function Est_Vide_t (T : T_TH) return Boolean;  
   |         -- Obtenir le nombre d'éléments d'une Sda.                                                 |          -- Obtenir le nombre d'éléments d'une TH.
   |         function Taille (Sda : in T_LCA) return Integer with                                       |          function Taille_t (T : in T_TH) return Integer with  
   |                 Post => Taille'Result >= 0                                                         |                  Post => Taille_t'Result >= 0
   |                         and (Taille'Result = 0) = Est_Vide (Sda);                                  |                          and (Taille_t'Result = 0) = Est_Vide_t (T);
   |         -- Enregistrer une Donnée associée à une Clé dans une Sda.                                 |          -- Enregistrer une Donnée associée à une Clé dans une TH.
   |         -- Si la clé est déjà présente dans la Sda, sa donnée est changée.                         |          -- Si la clé est déjà présente dans la TH, sa donnée est changée.
   |         procedure Enregistrer (Sda : in out T_LCA ; Cle : in T_Cle ; Donnee : in T_Donnee) with    |          procedure Enregistrer_t (T : in out T_TH ; Cle : in T_Cle_t ; Donnee : in T_Donnee_t) wi  
   |                 Post => Cle_Presente (Sda, Cle) and (La_Donnee (Sda, Cle) = Donnee)   -- donnée in |                  Post => Cle_Presente_t (T, Cle) and (La_Donnee_t (T, Cle) = Donnee)   -- donnée in
   |                                 and (not (Cle_Presente (Sda, Cle)'Old) or Taille (Sda) = Taille (S <
   |                                 and (Cle_Presente (Sda, Cle)'Old or Taille (Sda) = Taille (Sda)'Ol <
   |         -- Supprimer la Donnée associée à une Clé dans une Sda.                                    |                                  and (Cle_Presente_t (T, Cle)'Old or Taille_t (T) = Taille_t (T)'Ol
   |         -- Exception : Cle_Absente_Exception si Clé n'est pas utilisée dans la Sda                 <
   |         procedure Supprimer (Sda : in out T_LCA ; Cle : in T_Cle) with                             <
   |                 Post =>  Taille (Sda) = Taille (Sda)'Old - 1 -- un élément de moins                <
   |                         and not Cle_Presente (Sda, Cle);         -- la clé a été supprimée         <
   |                                                                                                    >          -- Supprimer la Donnée associée à une Clé dans une .
   |                                                                                                    >          -- Exception : Cle_Absente_Exception si Clé n'est pas utilisée dans la TH
   |                                                                                                    >          procedure Supprimer_t (T : in out T_TH ; Cle : in T_Cle_t) with  
   |                                                                                                    >                  Post =>  Taille_t (T) = Taille_t (T)'Old - 1 -- un élément de moins
   |                                                                                                    >                          and not Cle_Presente_t (T, Cle);         -- la clé a été supprimée
   |         -- Savoir si une Clé est présente dans une Sda.                                            <
   |         function Cle_Presente (Sda : in T_LCA ; Cle : in T_Cle) return Boolean;                    <
   |                                                                                                    >          -- Savoir si une Clé est présente dans une Sda.
   |                                                                                                    >          function Cle_Presente_t (T : in T_TH ; Cle : in T_Cle_t) return Boolean;  
   |         -- Obtenir la donnée associée à une Cle dans la Sda.                                       <
   |         -- Exception : Cle_Absente_Exception si Clé n'est pas utilisée dans l'Sda                  <
   |         function La_Donnee (Sda : in T_LCA ; Cle : in T_Cle) return T_Donnee;                      <
   |                                                                                                    >          -- Obtenir la donnée associée à une Cle dans la TH.
   |                                                                                                    >          -- Exception : Cle_Absente_Exception si Clé n'est pas utilisée dans la TH
   |                                                                                                    >          function La_Donnee_t (T : in T_TH ; Cle : in T_Cle_t) return T_Donnee_t;  
   |         -- Supprimer tous les éléments d'une Sda.                                                  <
   |         procedure Vider (Sda : in out T_LCA) with                                                  <
   |                 Post => Est_Vide (Sda);                                                            <
   |                                                                                                    >          -- Supprimer tous les éléments d'une TH.
   |                                                                                                    >          procedure Vider_t (T : in out T_TH) with  
   |                                                                                                    >              Post => Est_Vide_t (T);
   |                 with procedure Traiter (Cle : in T_Cle; Donnee: in T_Donnee);                      |                  with procedure Traiter_t(Cle : in T_Cle_t; Donnee: in T_Donnee_t);
   |         procedure Pour_Chaque (Sda : in T_LCA);                                                    |      procedure Pour_Chaque_t (T : in T_TH);  
   |                                                                                                    <
   |                                                                                                    <
   | -- AVEC_AFFICHER_DEBUG START DELETE                                                                <
   |         -- Afficher la Sda en révélant sa structure interne.                                       <
   |         --generic                                                                                  <
   |                 --with procedure Afficher_Cle (Cle : in T_Cle);                                    <
   |                 --with procedure Afficher_Donnee (Donnee : in T_Donnee);                           <
   |         --procedure Afficher_Debug (Sda : in T_LCA);                                               <
   |                                                                                                    <
   | -- AVEC_AFFICHER_DEBUG STOP DELETE                                                                 <
   |     type T_Cellule;                                                                                <
   |     type T_LCA is access  T_Cellule;                                                               <
   |     type T_Cellule is record                                                                       <
   |         Cle : T_Cle;                                                                               <
   |         Donnes: T_Donnee;                                                                          <
   |         Prochain : T_LCA;                                                                          <
   |     end record;                                                                                    <
   | end LCA;                                                                                           <
   |                                                                                                    >      type T_TH is array(1..Capacite) of T_LCA;  
   |                                                                                                    >  end TH;


================================================================================
## Différences entre test_lca.ads et test_th.ads
================================================================================

* Comparaison de test_lca.adb et test_th.adb... différents

   | with LCA;                                                                                          |  with TH;
   |         package LCA_String_Integer is                                                              |          package TH_String_Integer is
   |                 new LCA (T_Cle => Unbounded_String, T_Donnee => Integer);                          |                  new TH (T_Cle_t => Unbounded_String, T_Donnee_t => Integer, Capacite=>11, Fh=>Leng
   |         use LCA_String_Integer;                                                                    |          use TH_String_Integer;
   |                 new Pour_Chaque (Afficher);                                                        |                  new Pour_Chaque_t (Afficher);
   |         -- utilisant Vider.                                                                        |          -- utilisant Vider_t.
   |                 Initialiser (Annuaire);                                                            |                  Initialiser_t (Annuaire);
   |                 pragma Assert (Est_Vide (Annuaire));                                               |                  pragma Assert (Est_Vide_t (Annuaire));
   |                 pragma Assert (Taille (Annuaire) = 0);                                             |                  pragma Assert (Taille_t (Annuaire) = 0);
   |                         Enregistrer (Annuaire, Cles (I), Donnees (I));                             |                          Enregistrer_t (Annuaire, Cles (I), Donnees (I));
   |                         pragma Assert (not Est_Vide (Annuaire));                                   |                          pragma Assert (not Est_Vide_t (Annuaire));
   |                         pragma Assert (Taille (Annuaire) = I);                                     |                          pragma Assert (Taille_t (Annuaire) = I);
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_t (Annuaire, Cles (J)) = Donnees (J));
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_t (Annuaire, Cles (J)));
   |                 Vider (Annuaire);                                                                  |                  Vider_t (Annuaire);
   |                         Supprimer (Annuaire, Cles (I));                                            |                          Supprimer_t (Annuaire, Cles (I));
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_t (Annuaire, Cles (J)));
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_t (Annuaire, Cles (J)) = Donnees (J));
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_t (Annuaire, Cles (J)));
   |                 Vider (Annuaire);                                                                  |                  Vider_t (Annuaire);
   |                         Supprimer (Annuaire, Cles (I));                                            |                          Supprimer_t (Annuaire, Cles (I));
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_t (Annuaire, Cles (J)));
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_t (Annuaire, Cles (J)));
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_t (Annuaire, Cles (J)) = Donnees (J));
   |                 Vider (Annuaire);                                                                  |                  Vider_t (Annuaire);
   |                         Supprimer (Annuaire, Cles (Indice));                                       |                          Supprimer_t (Annuaire, Cles (Indice));
   |                                         pragma Assert (not Cle_Presente (Annuaire, Cles (J)));     |                                          pragma Assert (not Cle_Presente_t (Annuaire, Cles (J)));
   |                                         pragma Assert (Cle_Presente (Annuaire, Cles (J)));         |                                          pragma Assert (Cle_Presente_t (Annuaire, Cles (J)));
   |                         Vider (Annuaire);                                                          |                          Vider_t (Annuaire);
   |                 -- Tester enregistrer sur un élément présent, celui à Indice dans Cles.            |                  -- Tester Enregistrer_t sur un élément présent, celui à Indice dans Cles.
   |                         enregistrer (Annuaire, Cles (Indice), Nouveau);                            |                          Enregistrer_t (Annuaire, Cles (Indice), Nouveau);
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_t (Annuaire, Cles (J)));
   |                                         pragma Assert (La_Donnee (Annuaire, Cles (J)) = Nouveau);  |                                          pragma Assert (La_Donnee_t (Annuaire, Cles (J)) = Nouveau)
   |                                         pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J |                                          pragma Assert (La_Donnee_t (Annuaire, Cles (J)) = Donnees 
   |                         Vider (Annuaire);                                                          |                          Vider_t (Annuaire);
   |                         Supprimer (Annuaire, Inconnu);                                             |                          Supprimer_t (Annuaire, Inconnu);
   |                 Vider (Annuaire);                                                                  |                  Vider_t (Annuaire);
   |                         Inutile := La_Donnee (Annuaire, Inconnu);                                  |                          Inutile := La_Donnee_t (Annuaire, Inconnu);
   |                 Vider (Annuaire);                                                                  |                  Vider_t (Annuaire);
   |         procedure Tester_Pour_chaque is                                                            |          procedure Tester_Pour_Chaque_t is
   |                         new Pour_Chaque (Sommer);                                                  |                          new Pour_Chaque_t (Sommer);
   |                 Put_Line ("=== Tester_Pour_Chaque..."); New_Line;                                  |                  Put_Line ("=== Tester_Pour_Chaque_t..."); New_Line;
   |                 Vider(Annuaire);                                                                   |                  Vider_t(Annuaire);
   |         end Tester_Pour_chaque;                                                                    |          end Tester_Pour_Chaque_t;
   |         procedure Tester_Pour_chaque_Somme_Si_Cle_Commence_Par_Q is                                |          procedure Tester_Pour_Chaque_t_Somme_Si_Cle_Commence_Par_Q is
   |                         new Pour_Chaque (Sommer_Cle_Commence_Par_Q);                               |                          new Pour_Chaque_t (Sommer_Cle_Commence_Par_Q);
   |                 Put_Line ("=== Tester_Pour_Chaque_Somme_Si_Cle_Commence_Par_Q..."); New_Line;      |                  Put_Line ("=== Tester_Pour_Chaque_t_Somme_Si_Cle_Commence_Par_Q..."); New_Line;
   |                 Vider(Annuaire);                                                                   |                  Vider_t(Annuaire);
   |         end Tester_Pour_chaque_Somme_Si_Cle_Commence_Par_Q;                                        |          end Tester_Pour_Chaque_t_Somme_Si_Cle_Commence_Par_Q;
   |         procedure Tester_Pour_chaque_Somme_Len4_Erreur is                                          |          procedure Tester_Pour_Chaque_t_Somme_Len4_Erreur is
   |                         new Pour_Chaque (Sommer_Len4_Erreur);                                      |                          new Pour_Chaque_t (Sommer_Len4_Erreur);
   |                 Put_Line ("=== Tester_Pour_Chaque_Somme_Len4_Erreur..."); New_Line;                |                  Put_Line ("=== Tester_Pour_Chaque_t_Somme_Len4_Erreur..."); New_Line;
   |                 Vider(Annuaire);                                                                   |                  Vider_t(Annuaire);
   |         end Tester_Pour_chaque_Somme_Len4_Erreur;                                                  |          end Tester_Pour_Chaque_t_Somme_Len4_Erreur;
   |         Tester_Pour_chaque;                                                                        |          Tester_Pour_Chaque_t;
   |         Tester_Pour_chaque_Somme_Si_Cle_Commence_Par_Q;                                            |          Tester_Pour_Chaque_t_Somme_Si_Cle_Commence_Par_Q;
   |         Tester_Pour_chaque_Somme_Len4_Erreur;                                                      |          Tester_Pour_Chaque_t_Somme_Len4_Erreur;


================================================================================
## Exécution de th_sujet.adb
================================================================================

* Compilation de th_sujet.adb... ok

  | th.adb:1:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.adb:1:30: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:2:09: warning: unit "Ada.Unchecked_Deallocation" is not referenced

* ./th_sujet... ok
* valgrind ./th_sujet... ERREUR

  ! ==297606== Memcheck, a memory error detector
  ! ==297606== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==297606== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
  ! ==297606== Command: ./th_sujet
  ! ==297606== 
  ! ==297606== 
  ! ==297606== HEAP SUMMARY:
  ! ==297606==     in use at exit: 640 bytes in 14 blocks
  ! ==297606==   total heap usage: 14 allocs, 0 frees, 640 bytes allocated
  ! ==297606== 
  ! ==297606== 640 (48 direct, 592 indirect) bytes in 1 blocks are definitely lost in loss record 14 of 14
  ! ==297606==    at 0x4843839: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==297606==    by 0x4AE1FEE: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297606==    by 0x4B0F50C: system__pool_global__allocate (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297606==    by 0x4B1F176: system__storage_pools__subpools__allocate_any_controlled (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297606==    by 0x10DE94: th_sujet__th_string__lca_t__enregistrer__P205b.23 (lca.adb:44)
  ! ==297606==    by 0x10DCB3: th_sujet__th_string__lca_t__enregistrer.22 (lca.adb:35)
  ! ==297606==    by 0x10E44C: th_sujet__th_string__enregistrer_t.15 (th.adb:42)
  ! ==297606==    by 0x10CE15: _ada_th_sujet (th_sujet.adb:30)
  ! ==297606==    by 0x10CB6C: main (b~th_sujet.adb:290)
  ! ==297606== 
  ! ==297606== LEAK SUMMARY:
  ! ==297606==    definitely lost: 48 bytes in 1 blocks
  ! ==297606==    indirectly lost: 592 bytes in 13 blocks
  ! ==297606==      possibly lost: 0 bytes in 0 blocks
  ! ==297606==    still reachable: 0 bytes in 0 blocks
  ! ==297606==         suppressed: 0 bytes in 0 blocks
  ! ==297606== 
  ! ==297606== For lists of detected and suppressed errors, rerun with: -s
  ! ==297606== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


================================================================================
## Exécution de test_th.adb
================================================================================

* Compilation de test_th.adb... ok

  | test_th.adb:257:17: warning: variable "Inutile" is assigned but never read
  | test_th.adb:280:35: warning: formal parameter "Cle" is not referenced

* ./test_th... ok
* valgrind ./test_th... ERREUR

  ! ==297620== Memcheck, a memory error detector
  ! ==297620== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==297620== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
  ! ==297620== Command: ./test_th
  ! ==297620== 
  ! ==297620== 
  ! ==297620== HEAP SUMMARY:
  ! ==297620==     in use at exit: 1,312 bytes in 28 blocks
  ! ==297620==   total heap usage: 169 allocs, 141 frees, 12,672 bytes allocated
  ! ==297620== 
  ! ==297620== 1,312 (48 direct, 1,264 indirect) bytes in 1 blocks are definitely lost in loss record 14 of 14
  ! ==297620==    at 0x4843839: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==297620==    by 0x4AE1FEE: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297620==    by 0x4B0F50C: system__pool_global__allocate (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297620==    by 0x4B1F176: system__storage_pools__subpools__allocate_any_controlled (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==297620==    by 0x10DD2E: test_th__th_string_integer__lca_t__enregistrer__P358b.15 (lca.adb:44)
  ! ==297620==    by 0x10DB4D: test_th__th_string_integer__lca_t__enregistrer.11 (lca.adb:35)
  ! ==297620==    by 0x10E6B0: test_th__th_string_integer__enregistrer_t.10 (th.adb:42)
  ! ==297620==    by 0x10FA80: test_th__construire_exemple_sujet.4 (test_th.adb:77)
  ! ==297620==    by 0x10FE95: test_th__tester_supprimer_inverse.39 (test_th.adb:115)
  ! ==297620==    by 0x10D355: _ada_test_th (test_th.adb:372)
  ! ==297620==    by 0x10CBFC: main (b~test_th.adb:290)
  ! ==297620== 
  ! ==297620== LEAK SUMMARY:
  ! ==297620==    definitely lost: 48 bytes in 1 blocks
  ! ==297620==    indirectly lost: 1,264 bytes in 27 blocks
  ! ==297620==      possibly lost: 0 bytes in 0 blocks
  ! ==297620==    still reachable: 0 bytes in 0 blocks
  ! ==297620==         suppressed: 0 bytes in 0 blocks
  ! ==297620== 
  ! ==297620== For lists of detected and suppressed errors, rerun with: -s
  ! ==297620== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)



################################################################################
# Exercice 3
################################################################################


================================================================================
## Différences entre evaluer_alea_lca.ads et evaluer_alea_th.ads
================================================================================

* Comparaison de evaluer_alea_lca.adb et evaluer_alea_th.adb... différents

   | With LCA;                                                                                          |  With TH;
   | -- Évaluer la qualité du générateur aléatoire et les LCA.                                          |  -- Évaluer la qualité du générateur aléatoire et les TH.
   |                                                                                                    >      Function ident (n:in Integer) return integer is
   |                                                                                                    >      begin
   |                                                                                                    >          return n;
   |                                                                                                    >      end ident;
   |                                                                                                    >
   |                                                                                                    >
   |                                                                                                    >
   |         package LCA_alea is new LCA (T_Cle=>Integer, T_Donnee=>Integer);                           |
   |         use LCA_alea;                                                                              |          package TH_alea is new TH (T_Cle_t=>Integer, T_Donnee_t=>Integer,Capacite=>1000,Fh=> Ident
   |                                                                                                    >          use TH_alea;
   |                                                                                                    >
   |                                                                                                    >
   |         Initialiser(S);                                                                            |          Initialiser_t(S);
   |         Max:=1;                                                                                    |          Max:=0;
   |             if Cle_Presente(S,Aleatoire) then                                                      |              if Cle_Presente_t(S,Aleatoire) then
   |                 Enregistrer(S,Aleatoire,La_Donnee(S,Aleatoire)+1);                                 |                  Enregistrer_t(S,Aleatoire,La_Donnee_t(S,Aleatoire)+1);
   |                 Enregistrer(S,Aleatoire,1);                                                        |                  Enregistrer_t(S,Aleatoire,1);
   |             D:=La_Donnee(S,Aleatoire);                                                             |              D:=La_Donnee_t(S,Aleatoire);
   |             elsif Aleatoire = Min_Cle then                                                         |              elsif Aleatoire=Min_cle then
   |                 Min_cle:=Aleatoire;                                                                <
   |             else                                                                                   |                  Min_cle:=Aleatoire;
   |                 Null;                                                                              |


================================================================================
## Exécutions de evaluer_alea_*
================================================================================

* Running gnatclean... ok
* Compilation de evaluer_alea_lca.adb... ok

  | evaluer_alea_lca.adb:4:06: warning: no entities of "SDA_Exceptions" are referenced
  | evaluer_alea_lca.adb:4:28: warning: use clause for package "SDA_Exceptions" has no effect

* Compilation de evaluer_alea_th.adb... ok

  | evaluer_alea_th.adb:4:06: warning: no entities of "SDA_Exceptions" are referenced
  | evaluer_alea_th.adb:4:28: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:1:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.adb:1:30: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:2:09: warning: unit "Ada.Unchecked_Deallocation" is not referenced


================================================================================
## Tests nominaux
================================================================================


--------------------------------------------------------------------------------
### Cas : Classique : dé à 6 faces, 100 tirages
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 6 100... ok

  | Borne  : 6
  | Taille : 100
  | Min : 13
  | Max : 19

* valgrind ./evaluer_alea_lca 6 100... ERREUR

  ! ==297661== Memcheck, a memory error detector
  ! ==297661== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==297661== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
  ! ==297661== Command: ./evaluer_alea_lca 6 100
  ! ==297661== 
  ! ==297661== 
  ! ==297661== HEAP SUMMARY:
  ! ==297661==     in use at exit: 96 bytes in 6 blocks
  ! ==297661==   total heap usage: 17 allocs, 11 frees, 6,640 bytes allocated
  ! ==297661== 
  ! ==297661== 96 (16 direct, 80 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 6
  ! ... lignes suivantes supprimées ...

* ./evaluer_alea_th 6 100... ok

  | Borne  : 6
  | Taille : 100
  | Min : 14
  | Max : 20

* valgrind ./evaluer_alea_th 6 100... ERREUR

  ! ==297663== Memcheck, a memory error detector
  ! ==297663== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==297663== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
  ! ==297663== Command: ./evaluer_alea_th 6 100
  ! ==297663== 
  ! ==297663== 
  ! ==297663== HEAP SUMMARY:
  ! ==297663==     in use at exit: 96 bytes in 6 blocks
  ! ==297663==   total heap usage: 17 allocs, 11 frees, 6,640 bytes allocated
  ! ==297663== 
  ! ==297663== 96 bytes in 6 blocks are definitely lost in loss record 1 of 1
  ! ... lignes suivantes supprimées ...


--------------------------------------------------------------------------------
### Cas : Beaucoup de doubles
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 5 100... ok

  | Borne  : 5
  | Taille : 100
  | Min : 11
  | Max : 24

* ./evaluer_alea_th 5 100... ok

  | Borne  : 5
  | Taille : 100
  | Min : 16
  | Max : 25


--------------------------------------------------------------------------------
### Cas : Peu de doubles
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 100000 10... ok

  | Borne  : 100000
  | Taille : 10
  | Min : 1
  | Max : 1

* ./evaluer_alea_th 100000 10... ok

  | Borne  : 100000
  | Taille : 10
  | Min : 1
  | Max : 1


--------------------------------------------------------------------------------
### Cas : Limite pour Borne et Taille
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 2 2... ok

  | Borne  : 2
  | Taille : 2
  | Min : 1
  | Max : 2

* ./evaluer_alea_th 2 2... ok

  | Borne  : 2
  | Taille : 2
  | Min : 1
  | Max : 1


================================================================================
## Tests de robustesse
================================================================================


--------------------------------------------------------------------------------
### Cas : Deux entiers attendus
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ ZYT... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1

* ./evaluer_alea_th XYZ ZYT... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1


--------------------------------------------------------------------------------
### Cas : Taille doit être un entier
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 10 ZYT... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1

* ./evaluer_alea_th 10 ZYT... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1


--------------------------------------------------------------------------------
### Cas : Borne doit être un entier
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ 30... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1

* ./evaluer_alea_th XYZ 30... ok

  | Relancez le programme en entrant 2 entiers strictement supérieur à 1


--------------------------------------------------------------------------------
### Cas : Borne et Taille doivent être strictement positifs
--------------------------------------------------------------------------------

* ./evaluer_alea_lca -4 -10... ok

  | Borne  : -4
  | Taille : -10
  | Min : 1
  | Max : 1

* ./evaluer_alea_th -4 -10... ok

  | Borne  : -4
  | Taille : -10
  | Min : 1
  | Max : 0


--------------------------------------------------------------------------------
### Cas : Taille doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 4 -10... ok

  | Borne  : 4
  | Taille : -10
  | Min : 1
  | Max : 1

* ./evaluer_alea_th 4 -10... ok

  | Borne  : 4
  | Taille : -10
  | Min : 1
  | Max : 0


--------------------------------------------------------------------------------
### Cas : Borne doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca -4 10... ok

  | Borne  : -4
  | Taille : 10
  | Relancez le programme en entrant 2 entiers strictement supérieur à 1

* ./evaluer_alea_th -4 10... ok

  | Borne  : -4
  | Taille : 10
  | Relancez le programme en entrant 2 entiers strictement supérieur à 1


--------------------------------------------------------------------------------
### Cas : Il manque la taille (ou la borne)
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 5... ok

  | Usage : ./evaluer_alea_lca Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon

* ./evaluer_alea_th 5... ok

  | Usage : ./evaluer_alea_th Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon


--------------------------------------------------------------------------------
### Cas : Borne doit être un entier ou il manque la taille
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ... ok

  | Usage : ./evaluer_alea_lca Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon

* ./evaluer_alea_th XYZ... ok

  | Usage : ./evaluer_alea_th Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon


--------------------------------------------------------------------------------
### Cas : Taille doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 4 0... ok

  | Borne  : 4
  | Taille : 0
  | Min : 1
  | Max : 1

* ./evaluer_alea_th 4 0... ok

  | Borne  : 4
  | Taille : 0
  | Min : 1
  | Max : 0


--------------------------------------------------------------------------------
### Cas : Borne doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 0 100... ok

  | Borne  : 0
  | Taille : 100
  | Relancez le programme en entrant 2 entiers strictement supérieur à 1

* ./evaluer_alea_th 0 100... ok

  | Borne  : 0
  | Taille : 100
  | Relancez le programme en entrant 2 entiers strictement supérieur à 1


--------------------------------------------------------------------------------
### Cas : Borne = 1 : Ne respecte pas la précondition de Calculer_Statistiques
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 1 100... ok

  | Borne  : 1
  | Taille : 100
  | Min : 1
  | Max : 100

* ./evaluer_alea_th 1 100... ok

  | Borne  : 1
  | Taille : 100
  | Min : 1
  | Max : 100


--------------------------------------------------------------------------------
### Cas : Taille = 1 : Ne respecte pas la précondition de Calculer_Statistiques
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 10 1... ok

  | Borne  : 10
  | Taille : 1
  | Min : 1
  | Max : 1

* ./evaluer_alea_th 10 1... ok

  | Borne  : 10
  | Taille : 1
  | Min : 1
  | Max : 1



################################################################################
# Nettoyer
################################################################################

* Running gnatclean... ok

<!-- vi: set ts=8: -->
