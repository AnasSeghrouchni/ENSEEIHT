
with Ada.Unchecked_Deallocation;
with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;
with Ada.Text_IO; use Ada.Text_IO;


package body Chaine is

    procedure Free_Sda is
            new Ada.Unchecked_Deallocation (Object => T_Cellule, Name => T_Chaine);

    procedure Vider (Sda : in out T_Chaine) is
	begin
		if Sda /= Null then
			Vider (Sda.all.Suivante);
			Free_Sda (Sda);
        end if;


    end Vider;


    Procedure Initialiser(Sda: out T_Chaine) is
    begin
        Sda:=Null;
    end;

    function Est_Vide(Sda : in T_Chaine) return Boolean is
    begin
        return Sda=Null;
    end;

    procedure Enregistrer(Sda : in out T_Chaine; Octet : in T_Octet) is
    begin
        if Est_Present(Sda,Octet) then
            if Sda.all.Arbre.all.Cle = Octet then
                Sda.all.Arbre.all.Donnee:=Sda.all.Arbre.all.Donnee+1;
            elsif Sda.all.Suivante=null then
                Sda.all.Arbre.all.Donnee:=1;
                Sda.all.Arbre.all.Cle:=Octet;
            else
                Enregistrer(Sda.all.Suivante,Octet);
            end if;
        end if;
    end enregistrer;

    --jai pas compris in out pour file

    procedure Frequence(Sda : in out T_Chaine; File_Name : in String ;File : in out Ada.Streams.Stream_IO.File_Type) is
        S : Stream_Access;
        Octet : T_Octet;
    begin
        Initialiser(Sda);
        Open(File,In_File,File_Name);
        S:=Stream(File);
        while not End_Of_File(File) loop
            Octet:=T_Octet'Input(S);
            Enregistrer(Sda,Octet);
            New_Line;
        end loop;
        Close(File);
    end Frequence;



    procedure Vider_Sda(Sda : in out T_Chaine) is
    begin
        if Sda.all.Suivante=Null then
            Free_Sda(Sda);
        else
            Vider_Sda(Sda.all.Suivante);
            Free_Sda(Sda);
        end if;
    end Vider_Sda;




    procedure Supprimer(Sda : in out T_Chaine; Frequence : in integer) is
    begin
        if Sda.all.Arbre.all.Donnee=Frequence then
            Sda:=Sda.all.suivante;
        else
            Supprimer(Sda.all.suivante, Frequence);
        end if;
    end Supprimer;




    procedure Min_arbre(Sda:in T_Chaine;Min :in out integer;Arbre_min: out T_Arbre) is
    begin
        if Sda.all.Arbre.all.Donnee<Min then
            Min:=Sda.all.Arbre.all.Donnee;
            Arbre_min:=Sda.all.Arbre;
        end if;
        if Sda.all.Suivante/=Null then
            Min_arbre(Sda.all.Suivante,Min,Arbre_min);
        end if;
    end Min_arbre;

    procedure Deux_min(Sda: in out T_Chaine; arbre_min1: out T_Arbre; arbre_min2:out T_Arbre) is
        f:integer;
    begin
        f:=Sda.all.arbre.all.Donnee;
        Min_arbre(Sda,f,arbre_min1);
        Supprimer(Sda,f);
        f:=Sda.all.arbre.all.Donnee;
        Min_arbre(Sda,f,arbre_min2);
    end Deux_min;



    procedure Construction_Arbre(Sda: in out T_Chaine; Arbre : out T_Arbre) is
        Ch:T_Chaine;
        Arbre_min1:T_arbre;
        Arbre_min2:T_Arbre;
    begin
        Initialiser(Sda);
        if Sda.all.suivante=Null then
            Arbre:=Sda.all.arbre;
        else
            Deux_Min(Sda,Arbre_min1,Arbre_min2);
            Ch:=new T_Cellule;
            Ch.all.Arbre.all.Gauche:=Arbre_min1;
            Ch.all.Arbre.all.Droite:=Arbre_min2;
            Ch.all.Arbre.all.Donnee:=Arbre_min1.all.Donnee+Arbre_min2.all.Donnee;
            Ch.all.suivante:=Sda;
            Sda:=Ch;
            Construction_Arbre(Sda,Arbre);
        end if;
    end Construction_Arbre;


    function Est_Present(Sda : in T_Chaine; Octet : in T_Octet) return Boolean is
    begin
        if Sda.all.Suivante=Null then
            return Sda.all.Arbre.all.Cle=Octet;
        else
            return Sda.all.Arbre.cle=Octet or Est_Present(Sda.all.Suivante,Octet);
        end if;
    end Est_Present;


end Chaine;
