with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Unchecked_Deallocation;
with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;
with Ada.Text_IO; use Ada.Text_IO;

--generic
 --   type T_Donnee is private;
   -- type T_Cle is private;

package Arbre is
    type T_Octet is private;
    type T_Arbre is private;
    type T_Chaine is private;

    --Savoir si un arbre n'a pas de fils gauche ni de fils droit (c'est une feuille).
    function Est_Feuille(Arbre : in T_Arbre) return boolean ;

    function Est_Vide_Arbre(Arbre : in T_Arbre) return Boolean;

    --Construire le code de l'arbre à partir de l'arbre
    function Code(Arbre:in T_Arbre) return Unbounded_String;

    	-- Supprimer tous les Ã©lÃ©ments d'une Sda.
	procedure Vider_arbre (Arbre: in out T_Arbre) with
            Post => Est_Vide_Arbre (Arbre);

    procedure Frequence(Sda : in out T_Chaine; File_Name : in String ;File : in out Ada.Streams.Stream_IO.File_Type);

    procedure Construction_Arbre(Sda: in out T_Chaine; Arbre : out T_Arbre);

     -- Initialiser une Sda.  La Sda est vide.
    procedure Initialiser(Sda: out T_Chaine) with
        Post => Est_Vide (Sda);

    -- Est-ce qu'une Sda est vide ?
    function Est_Vide (Sda : T_Chaine) return Boolean;

    -- Savoir si une Clé est présente dans une Sda.
    function Est_Present (Sda : in T_Chaine ; Octet : in T_Octet) return Boolean;

   --Ajouter un arbre associé à un caractere dans la chaine s'il n'y est pas, incrémenter sa fréquence correspondante s'il y est
    procedure Enregistrer (Sda : in out T_Chaine ; Octet : in T_Octet) ;

    -- Supprimer tous les éléments d'une Sda.
    procedure Vider (Sda : in out T_Chaine) with
            Post => Est_Vide (Sda);
    --Supprimer la case contenant ATTENTION
    procedure Supprimer( Sda : in out T_Chaine;Frequence : in integer) ;

private

    type T_Octet is mod 2 ** 8;
    for T_Octet'Size use 8;
    type T_Noeud;
    type T_Arbre is access T_Noeud;
    type T_Noeud is record
        Cle : T_Octet;
        Donnee : integer;
        Droite : T_Arbre;
        Gauche : T_Arbre;
    end record;
    type T_Cellule;

    type T_Chaine is access T_Cellule;

    type T_Cellule is record
        Arbre : T_Arbre;
        Suivante : T_Chaine;
    end record;

end Arbre;

